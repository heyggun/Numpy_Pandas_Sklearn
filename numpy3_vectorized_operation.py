# -*- coding: utf-8 -*-
"""Numpy3_vectorized_operation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H9TYkvj0EKoXFzQscpiYz5hUe_q1TZC7
"""

import numpy as np

# 3.3 배열의 연산 
# 벡터화 연산

# numpy -> 벡터화 연산(vectorized operation) 지원 
# 벡터화 연산을 쓰면 명시적으로 반복문을 사용하지 않고도, 배열의 모든 원소에 대해 반복연산 가능
# 벡터화 연산의 또 다른 장점은 선형 대수 공식과 동일한 파이썬 코드를 작성할 수 있다는 것임

# %%time 코드 -> 셀 코드의 실행시간을 측정하는 아이파이썬 매직 명령어

x = np.arange(1, 10001)
y = np.arange(10001, 20001)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# z = np.zeros_like(x)
# for i in range(10000):
#   z[i] = x[i] + y[i]

z[:10]

# 사칙연산 뿐 아니라 비교연산과 같은 논리 연산도 벡터화 연산 가능

a = np.array([1,2,3,4])
b = np.array([4,2,2,4])

a==b

# 만약 배열의 각 원소들을 일일히 비교하는 것이 아니라, 배열의 모든 원소가 다 같은지 알고 싶으면
# all 명령어를 사용하면 됨

a = np.array([1,2,3,4])
b = np.array([4,2,2,4])
c = np.array([1,2,3,4])

np.all(a == b)

print(np.all(b==c))
print(np.all(a==c))

# 지수함수,로그함수 등의 수학함수도 벡터화 연산을 지원

a = np.arange(5)
a

np.exp(a)

10 ** a

np.log(a+1)

# 스칼라와 벡터/행렬의 곱셈

x = np.arange(10)
x

100 * x

x = np.arange(12).reshape(3,4)
x

100 * x

# 브로드캐스팅

# 벡터(또는 행렬) 끼리 덧셈 혹은 뺄셈을 하려면 두 벡터(또는 행렬)의 크기가 같아야 한다.
# 넘파이에서는 서로 다른 크기를 가진 두 배열의 사칙 연산도 지원한다.
# 이 기능을 브로드캐스팅(broadcasting) 이라고 함
# 크기가 작은 배열을 자동으로 반복 확장하여 크기가 큰 배열에 맞추는 방식

x = np.arange(5)
x

y = np.ones_like(x)
y

x+y

x+1

# 브로드캐스팅은 다음처럼 더 차원이 높은 경우에도 적용됨

x = np.vstack([range(7)[i:i+3] for i in range(5)])
x

x1 = np.array([range(7)[0:3]])
x2 = np.array([range(7)[1:4]])
x3 = np.array([range(7)[2:5]])
x4 = np.array([range(7)[3:6]])
x5 = np.array([range(7)[4:7]])

print(x1,x2,x3,x4,x5)

y = np.arange(5)[:,np.newaxis]
y

y = np.arange(5)
print(y)
y1 = np.arange(5)[:]
print(y1)
y2 = np.arange(5)[:3, np.newaxis]
print(y2)

x+y

y = np.arange(3)
y

x + y

# 차원 축소 연산

# 행렬의 하나의 행에 있는 원소들을 하나의 데이터 집합으로 보고, 그 집합의 평균을 구하면
# 각 행에 대해 하나의 숫자가 나오게 된다. 예를 들어 10x5 크기의 2차원 배열에 대해 행-평균을 구하면
# 10개의 숫자를 가진 1차원 벡터가 나오게 된다.
# 이러한 연산을 차원 축소(dimension reduction) 연산이라고 한다.

# 넘파이는 차원 축소 연산 명령 혹은 메서드 지원
# 최대/최소 : min, max, argmin, argmax
# 통계 : sum, mean, median, std, var
# 불리언 : all, any

x = np.array([1,2,3,4])
x

np.sum(x)

x.max()

x.argmin() #최소값의 위치

x.argmax() #최대값의위치

x = np.array([1,2,3,1])

x.mean()

np.median(x)

np.all([True, True, False])

np.any([True, True, False])

a = np.zeros((100,100), dtype = np.int)
a

np.any( a!=0)

np.all(a==a)

a = np.array([1,2,3,2])
b = np.array([2,2,3,2])
c = np.array([6,4,4,5])

((a<=b)& (b<=c)).all()

# 연산의 대상이 2차원 이상인 경우에는 어느 차원으로 계산을 할 지를 axis 인수를 사용하여 지시함
# axis = 0 인 경우 열 연산, axis = 1 일 경우 행 연산이다.
# 디폴트 값은 axis=0이다. axis 인수는 대부분의 차원 축소 명령에 적용할 수 있음

x = np.array([[1,1], [2,2]])
x

x.sum()

x.sum(axis=0) # 열 합계

x.sum(axis=1) # 행 합계

# ex 3.3.1 
# 실수로 이루어진 5x6 형태의 데이터 행렬을 만들고 이 데이터에 대한 다음과 같은 값을 구하기
# 1. 전체행의 최댓값
# 2. 각 행의 합
# 3. 각 행의 최댓값
# 4. 각 열의 평균
# 5. 각 열의 최솟값

ex = np.ones((5,5), dtype=np.float)
ex.max()

np.sum(ex)

ex.max()

print(ex.mean())

ex.min()

# 정렬
# sort 함수나 메서드를 사용하여 배열 안의 원소를 크기에 따라 정렬하여, 새로운 배열을 만들 수도 있다.
# 2차원 이상인 경우에는 행이나 열을 각각 따로따로 정렬하는데 axis 인수를 사용하여, 행을 정렬할 것인지
# 열을 정렬할 것인지 결정한다.
# axis=0이면 각각의 행을 따로 정렬 axis=1 이면 각각의 열을 따로 정렬 한다.
# 디폴트 값은 -1, 가장 안쪽(나중)의 차원이다.

a = np.array([[4,3,5,7], [1,12,11,9],[2,15,1,14]])
a

np.sort(a) # axis=-1 또는 axis=1과 동일

np.sort(a, axis=0)

# sort 메서드는 해당 객체의 자료 자체가 변화하는 자체변화(in-place) 메서드이므로, 사용할 때 주의를 기울여야 한다.

a.sort(axis=1)
a

#만약 자료를 정렬하는 것이 아니라 순서만 알고 싶다면, argsort명령을 사용한다.

a = np.array([42,38,12,25])
j = np.argsort(a)
j

a[j]

a[np.argsort(a)]

np.sort(a)

# 연습문제 3.3.2
# 다음 배열은 첫번째 행(row)에 학번, 두번째 행에 영어 성적, 세번째 행에 수학 성적을 적은 배열이다.
# 영어 성적을 기준으로 각 열(column)을 재 정렬하라.

ex3 = np.array([[1,2,3,4],[46,99,100,71],[81,59,90,100]])
ex3

np.sort(ex3,axis=1)

