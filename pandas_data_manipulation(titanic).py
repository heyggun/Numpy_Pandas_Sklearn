# -*- coding: utf-8 -*-
"""Pandas_Data_Manipulation(titanic)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rkPDYYtAbfcMFPXOmJrrcwc-1iEyuNID
"""

# 모든 행과 열에 라벨을 가지는 5x5 이상의 크기를 가지는 데이터프레임

import pandas as pd
import numpy as np

df = pd.DataFrame(np.arange(1,26).reshape(5,5),
                  index = ["a","b","c","d","e"],
                  columns = ["A","B","C","D","E"])
df

df.loc["d","D"]

df.iloc[3,3]

# 데이터프레임의 데이터 조작
# 판다스는 넘파이 2차원 배열에서 가능한 대부분의 데이터 처리가 가능,
# 추가로 데이터 처리 및 변환을 위한 다양한 함수와 메서드를 제공함

# 데이터 갯수 세기(count 메서드)

s = pd.Series(range(10))
s[3] = np.nan
s

s.count() # NaN 값은 세지 않음

# 데이터프레임에서는 각 열마다 별도로 데이터 갯수를 셈
# 데이터에서 값이 누락된 부분을 찾을 때 유용함

np.random.seed(2)
df = pd.DataFrame(np.random.randint(5, size=(4,4)), dtype=float)
df.iloc[2,3] = np.nan
df

df.count()

# 타이타닉호의 승객 데이터를 데이터프레임으로 읽어옴

import seaborn as sns

titanic = sns.load_dataset("titanic")
titanic.head()

# 타이타닉 호 갯수의 데이터의 데이터 개수를 각 열마다 구하기

titanic.count()

# 카테고리 값 세기

# 시리즈의 값이 정수, 문자열, 카테고리 값인 경우에는 value_counts 메서드로 각각의 값이 나온 횟수를 셀 수 있음

np.random.seed(1)
s2 = pd.Series(np.random.randint(6, size=100))
s2.tail()

s2.value_counts()

# 데이터프레임에는 value_counts 메서드가 없으므로 각 열마다 별도 적용

df[0].value_counts()

df[1].value_counts()

# 정렬

# 데이터를 정렬하려면 sort_index 메서드 sort_values 메서드 사용
# sort_index 는 인덱스 값을 기준, sort_values 메서드는 데이터 값을 기준으로 적용

# 시리즈 s2의 각 데이터 값에 따른 데이터 갯수를 인덱스에 따라 정렬하려면, 
# 다음 처럼 sort_index를 적용한다.

s2.value_counts().sort_index()

# NaN 값이 있을 경우 정렬하면 NaN 값이 가장 나중으로 감

s.sort_values()

# 큰 수에서 작은 수로 반대 방향 정렬하려면 ascending=False 인수 지정

s.sort_values(ascending=False)

# 데이터프레임에서 sort_values 메서드를 사용하려면 by 인수로 정렬 기준이 되는 열을 지정

df.sort_values(by=1)

df.sort_values(by=2)

df.sort_values(by=3)

df

# by 인수에 리스트 값을 넣으면 이 순서대로 정렬 기준의 우선 순위가 됨,
# 즉 리스트의 첫번째 열을 기준으로 정렬한 후 동일 값이 나오면 그 다음 열로 순서를 따짐

df.sort_values(by=[1,2])

# sort_values 메서드를 사용하여 타이타닉호 승객에 대해 성별(sex) 인원수,
# 나이별(age) 인원 수, 선실별(class) 인원 수, 사망/생존(alive) 인원수는?

titanic.head()

titanic["sex"].value_counts()

titanic["age"].value_counts().sort_index()

titanic["class"].value_counts().sort_index()

titanic["alive"].value_counts()

# 행/열 합계

# 행과 열의 합계를 구할 때는 sum(axis) 메서드를 사용
# axis 인수에는 합계로 인해 없어지는 방향 축(0=행, 1=열)을 지정

np.random.seed(1)
df2 = pd.DataFrame(np.random.randint(10, size=(4,8)))
df2

# 행방향 합계를 구할 때는 sum(axis= 1)

df2.sum(axis=1)

df2["RowSum"] = df2.sum(axis=1)
df2

# 열 합계를 구할 때는 sum(axis=0) 메서드 사용,axis 인수의 디폴드 값이 0임로 axis 인수 생략

df.sum()

df2.loc["ColTotal", :] = df2.sum()
df2

# mean 메서드는 평균을 구하며 sum 메서드와 사용법이 같음

# ex 1) 타이타닉호 승객의 평균 나이
# 2) 승객 중 여성 승객의 평균 나이
# 3) 승객 중 1등실 선실의 여성 승객 나이의 평균 나이

titanic.head()

titanic["age"].mean()

titanic.loc[titanic.sex == "female"]["age"].mean()

titanic.loc[(titanic['sex'] == "female") & (titanic["class"] == "First")]["age"].mean()

# apply 변환

# 행이나 열 단위로 더 복잡한 처리를 하고 싶을 때는 apply 메서드를 사용함
# 인수로 행 또는 열을 받는 함수를 apply 메서드의 인수로 넣으면 각 열(또는 행)을 반복하여 그 함수에 적용

df3 = pd.DataFrame({
    'A' :[1,3,4,3,4],
    'B' :[2,3,1,2,3],
    'C' :[1,5,2,4,4]
})

df3

# 각 열의 최대값과 최소값의 차이를 알고 싶으면 다음과 같은 람다 함수를 넣음

df3.apply(lambda x: x.max() - x.min())

# 만약 행에 적용하고 싶으면 axis=1 인수를 씀

df3.apply(lambda x: x.max() - x.min(), axis=1)

# 각 열에 대해 어떤 값이 얼마나 사용되었는지 알고 싶다면 value_counts 함수를 넣음

df3.apply(pd.value_counts)

df3

# 타이타닉호의 승객 중 나이 20살을 기준으로 성인(adult)와 미성년자(child)를 구별하는 라벨 열

titanic["adult/child"] = titanic.apply(lambda r : "adult" 
                                       if r.age >= 20 else "child", axis=1)
titanic.tail()

# ex : 타이타닉호의 승객에 대해 나이와 성별에 의한 카테고리 열 category1 열 만들기 
# ex1) 20살이 넘으면 성별을 그대로 사용
# ex2) 20살 미만이면 성별에 관계없이 'child'라고 함

titanic["category1"] = titanic.apply(lambda r: "child" if r.age < 20 else r.sex, axis=1)

titanic.tail()

# fillna 메서드

# NaN 값은 fillna 메서드를 사용하여 원하는 값으로 바꿀 수 있음

df3

df3.apply(pd.value_counts).fillna(0.0)

# 타이타닉호의 승객 중 나이를 명시하지 않은 고객은
# 나이를 명시한 고객의 평균 나이 값이 되도록 titanic 데이터 프레임 고치기

age_mean = titanic["age"].mean()
print(age_mean)

titanic["age"].fillna(age_mean, inplace=True)
titanic.tail()

#astype 메서드

#astype 메서드로 전체 데이터의 자료형을 바꾸는 것 가능

df3.apply(pd.value_counts).fillna(0).astype(int)

# ex. 타이타닉호의 승객에 나이와 성별에 의한 카테고리 category2 열 만들기
# category2 는 1) 성별을 나타내는 문자열 male 또는 female로 시작
# 성별을 나타내는 문자열 뒤에 나이를 나타내는 문자열이 옴
# 예를 들어 27살 남성은 male27이 됨

titanic["age"] = titanic["age"].astype(float)
titanic["age"] = titanic["age"].astype(int)
titanic["age"] = titanic["age"].astype(str)

titanic["category2"] = titanic[["sex","age"]].apply(''.join,axis=1)
titanic

# 실수 값을 카테고리 값으로 변환

# 실수 값을 크기 기준으로 하여 카테고리 값으로 변환하고 싶을 때는 아래와 같은 명령 사용

# cut : 실수 값의 경계선을 지정할 경우
# qcut : 갯수가 똑같은 구간으로 나누는 경우

ages = [0, 2, 10, 21, 23, 37, 31, 61, 20, 41, 32, 101]

# cut 명령 사용시 실수값을 다음처럼 카테고리 값으로 바꿀 수 있음
# bins 인수는 카테고리를 나누는 기준값이 됨
# 영역 넘는 값은 NaN으로 처리

bins = [1, 20, 30, 50, 70, 100]
labels = ["미성년자", "청년", "중년", "장년", "노년"]
cats = pd.cut(ages, bins, labels=labels)
cats

# cut 명령이 반환하는 값은 categorical 클래스 객체애다.
# 이 객체는 categories 속성으로 라벨문자열을,
# codes 속성으로 정수로 인코딩한 카테고리 값을 가진다.

type(cats)

cats.categories

cats.codes

df4 = pd.DataFrame(ages, columns=["ages"])
df4

df4["age_cat"] = pd.cut(df4.ages, bins, labels=labels)
df4

# 따라서 위 데이터프레임의 age_cat 열값은 문자열이 아님
# 이를 문자열로 만들려면 astype 메서드를 사용해야함

df4.age_cat.astype(str) + df4.ages.astype(str)

# qcut 명령은 구간 경계선을 지정하지 않고 데이터 갯수가 같도록 지정한 수의 구간
# 다음 코드는 1000개의 데이터를 4개의 구간으로 나누는데, 각 구간은 250개씩의 데이터를 가짐

data= np.random.randn(1000)
cats = pd.qcut(data, 4, labels=["Q1","Q2","Q3","Q4"])
cats

pd.value_counts(cats)

# 타이타닉호 승객을 '미성년자' , '청년', '중년', '장년', '노년' 나이 그룹으로 나눈다.
# bins =[ 1,20, 30, 50, 70, 100]
# labels = ["미성년자", "청년", "중년", "장년", "노년"]

bins = [0, 20, 30, 50, 70, 100]
labels = ["미성년자", "청년", "중년", "장년", "노년"]

rate_age = sum(titanic["age"].value_counts())

age_cats= pd.cut(titanic["age"], bins, labels=labels)
age_cats

print((age_cats.value_counts()/rate_age)*100)

# 타이타닉호의 승객에 대해 나이와 성별에 의한 카테고리 열인 category3 만들기
# 20살 미만이면 성별에 관계없이 "미성년자"
# 20살 이상이면 나이에 따라 "청년"."중년","장년",:노년" 구분, 뒤에 성별을 나타내는 "남성" 여성"



