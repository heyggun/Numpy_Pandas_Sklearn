# -*- coding: utf-8 -*-
"""Pandas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TRI1u__5QQhb3PA_xnaCArrFrlC9aAIF
"""

# 판다스 데이터 분석

# 대부분 데이터는 시계열(series)이나 표(table) 형태로 나타낼 수 있음
# 판다스(Pandas) 패키지는 데이터를 다루기 위한(Series) 클래스와 데이터 프레임(DataFrame) 클래스를 제공

import pandas as pd

# 시리즈 클랫 (Series 클래스는 넘파이의 1차원 배열과 비슷하지만,
# 각 데이터의 의미를 표시하는 인덱스를 붙일 수 있음)
# 데이터 자체는 값(value)라고 함

# 시리즈 = 값(value) + 인덱스(index)

# 시리즈 생성 
# 데이터를 리스트나 1차원 배열 형식으로 Series 클래스 생성자에 넣어주면, 시리즈 클래스 객체를 만들 수 있음
# 인덱스의 길이는 데이터의 길이와 같아야 함
# 인덱스의 값을 인덱스 라벨(label)이라고 함
# 인덱스 라벨은 문자열 뿐 아니라 날짜, 시간, 정수 등도 가능

s = pd.Series([9904312, 3448737, 2890451, 2466052], index = ["서울", "부산", "인천", "대구"])
s

pd.Series(range(10, 14)) # 인덱스를 지정하지 않고 시리즈를 만들면 시리즈의 인덱스는 0부터 시작

# 시리즈의 인덱스는 index 속성으로 접근가능.
# 시리즈의 값은 1차원 배열이며, values 속성으로 접근 가능

s.index

s.values

# name 속성을 이용하여 시리즈 데이터에 이름을 붙일 수 도 있음
# index.name 속성으로 시리즈의 인덱스에도 이름을 붙일 수 있음

s.name = "인구"
s.index.name = "도시"
s

# 시리즈 연산

# 넘파이 배열처럼 시리즈도 벡터화 연산을 할 수 있다.
# 다만 연산은 시리즈의 값에만 적용되며 인덱스의 값은 변하지 않는다.
# 예를 들어 인구 숫자를 백만 단위로 만들기 위해 시리즈 객체를 1,000,000 으로 나누어도 
# 인덱스 라벨에는 영향을 미치지 않는 것을 볼 수 있다.

s/10000000

# 시리즈 인덱싱

# 시리즈는 넘파이 배열에서 가능한 인덱스 방법 이외에도 인덱스 라벨을 이용한 인덱싱도 할 수 있다.
# 배열 인덱싱이나 인덱스 라벨을 이용한 슬라이싱(slicing)도 가능함

# 시리즈 데이터를 인덱싱하면 값이 나옴

s[1], s["부산"]

s[0], s["인천"]

# 배열 인덱싱을 하면 부분적인 값을 가지는 시리즈 자료형을 반환함
# 자료의 순서를 바꾸거나 특정한 자료만 선택할 수 있음

s[[0,3,1]]

s[[1,3,1]]

s[[0,3,2]]

s[["서울", "대구", "부산"]]

s[(250e4 <s) & (s <500e4)] # 인구가 250만 초과, 500만 미만인 경우

# 슬라이싱을 해도 부분적인 시리즈를 반환함
# 문자열 라벨을 이용한 슬라이싱을 하는 경우에는
# 숫자 인덱싱과 달리 콜론(:) 기호 뒤에 오는 값도 결과에 포함되므로 주의해야 함

s[1:3]

s["부산" : "대구"]

# 만약 라벨 값이 영문 문자열인 경우 인덱스 라벨이 속성인 것 처럼 점(.)을 이용하여 해당 인덱스에 접근 가능

s0 = pd.Series(range(3), index= ["a","b","c"])
s0

s0.a

s0.b

#시리즈와 딕셔너리 자료형

#시리즈 객체는 라벨 값에 의해 인덱싱이 가능하므로 실질적으로 인덱스 라벨 값을 키(key)로 가지는
# 딕셔너리 자료형과 같음
# 따라서 딕셔너리 자료형에서 제공하는 in 연산도 가능하고 items 메서드를 사용하면 for 루프를 통해
# 각 원소의 키(key)와 값(value)을 접근할 수 있음

"서울" in s # 인덱스 라벨 중에 서울이 있는가

"대전" in s # 인덱스 라벨 중에 대전이 있는가

for k,v in s.items():
  print("%s = %d" %(k,v))

# 또 딕셔너리 객체에서 시리즈를 만들 수 있음
# 이번에는 2010년 인구 자료를 s2라는 이름의 시리즈를 만들 때,
# 이 데이터에는 대구의 인구 자료는 없지만 대신 대전의 인구자료가 포함되어 있다.

s2 = pd.Series({"서울" : 9631482, "부산" : 3393191, "인천" : 2632035, "대전" : 1490158})
s2

# 딕셔너리 원소는 순서를 가지지 않으므로 시리즈의 데이터도 순서가 보장되지 않음
# 만약 순서를 정하고 싶다면 인덱스를 리스트로 지정해야 함

s2 = pd.Series({"서울" : 9631482, "부산" : 3393191, "인천" : 2632035, "대전" : 1490158}, 
               index = ["부산", "서울", "인천", "대전"])
s2

# 인덱스 기반 연산

# 2015년과 2010년의 인구 증가를 계산, 두 개의 시리즈의 차이를 구하면 됨
# 두 시리즈에 대해 연산을 하는 경우 인덱스가 같은 데이터에 대해서만 차이를 구함

ds = s - s2
ds

s.values - s2.values

# 대구와 대전의 경우 2010년 자료와 2015년 자료가 모두 존재하지 않기 때문에 계산이 불가능 함
# NaN(Not a Number) 라는 값을 가지게 됨. 또한 NaN 값이 float 자료형에서만 가능, 다른 계산 결과도 모두 float 자료형
# NaN이 아닌 값을 구하려면 notnull 메서드를 사용

ds.notnull()

ds[ds.notnull()]

# 마찬가지로 인구 증가율(%)은 다음과 같이 구할 수 있따.

rs = (s - s2) / s2 * 100
rs = rs[rs.notnull()]
rs

# 데이터의 갱신, 추가, 삭제

# 인덱싱을 이용하면 딕셔너리처럼 데이터를 갱신(update)하거나 추가(add)할 수 있음

rs["부산"] = 1.63
rs

rs["대구"] = 1.41
rs

# 데이터를 삭제할 때도 딕셔너리처럼 del 명령을 사용함
del rs["서울"]
rs

# ex (1) 임의로 두 개의 시리즈 객체를 만듦. 모두 문자열 인덱스를 가져야 하며,
# 두 시리즈에 공통적으로 포함되지 않는 라벨이 있어야 함
# (2) 위에서 만든 두 시리즈 객체를 이용하여 사칙 연산을 함

e1 = pd.Series({"사과" : 1234, "배" : 5678, "고구마" : 9109}, index=["사과","배","고구마"])
e2 = pd.Series({"오렌지" : 1234, "배" : 5000, "고구마" : 9000}, index = ["오렌지", "배", "고구마"])

de = e1-e2 
de[de.notnull()]
de2 = e1+e2
de2[de.notnull()]

#데이터프레임 클래스

# 시리즈가 1차원 벡터 데이터에 행방향 인덱스(row index)를 붙인 것이라면,
# 데이터프레임 DataFrame 클래스는 2차원 행렬 데이터에 인덱스를 붙인 것과 비슷함
# 2차원이므로 각각의 행 데잍의 이름이 되는 행 인덱스(row index) 뿐 아니라,
# 각각의 열 데이터의 이름이 되는 열 인덱스(column index)도 붙일 수 있다.

# 데이터 프레임 생성

# 1) 우선 하나의 열이 되는 데이터를 리스트나 일차원 배열을 준비
# 2) 이 각각의 열에 대한 이름(라벨)을 키로 가지는 딕셔너리 만듦
# 3) 이 데이터를 DataFrame 클래스 생성자에 넣음. 
# 동시에 열방향 인덱스는 columns 인수로, 행방향 인덱스는 index 인수로 지정

data = {
    "2015" : [9904312, 3448737, 2890451, 2466052],
    "2010" : [9631482, 3393191, 2632035, 2431774],
    "2005" : [9762546, 3512547, 2517680, 2456016],
    "2000" : [9853972, 3655437, 2466338, 2473990],
    "지역" : ["수도권", "경상권", "수도권", "경상도"],
    "2010-2015 증가율" : [0.0283, 0.0163, 0.0982, 0.0141]
}

columns = ["지역", "2015", "2010", "2005", "2000", "2010-2015 증가율"]
index = ["서울", "부산", "인천", "대구"]

df = pd.DataFrame(data, index=index, columns=columns)
df

# 데이터프레임은 2차원 배열 데이터를 기반으로 한다고 했지만, 사실은 공통 인덱스를 가지는
# 열 시리즈(column series)를 딕셔너리로 묶어놓은 것이라고 보는 것이 정확함
# 2차원 배열 데이터는 모든 원소가 같은 자료형을 가져야 하지만, 데이터프레임은 각 열(column)마다 자료형이 다를 수 있음
# 위 예제에서도 지역과 인구 증가율은 각각 문자열, 정수, 부동소수점 실수임

# 시리즈와 마찬가지로 데이터만 접근하려면 values 속성을 사용
# 열방향 인덱스와 행방향 인덱스는 각각 columns, index 속성으로 접근

df.values

df.columns

df.index

# 시리즈에서 처럼 열방향 인덱스와 행방향 인덱스에 이름을 붙이는 것도 가능함

df.index.name = "도시"
df.columns.name ="특성"
df

# ex : 다음 조건을 만족하는 임의의 데이터프레임 생성
# (1) 열의 갯수와 행의 갯수가 각각 5개 이상이여야 함
# (2) 열에는 정수, 묹열, 실수 자료형 데이터가 각각 1개 이상씩 포함

#

#데이터 프레임은 전치(Transpose)를 포함하여 넘파이 2차원 배열이 가지는 대부분의 속성고 메서드 지원

df.T

# 열 데이터의 갱신, 추가, 삭제

# 데이터프레임은 열 시리즈의 딕셔너리로 볼 수 있으므로 열 단위로 데이터를 갱신하거나 추가, 삭제 함

# 2010-2015 증가율" 이라는 이름의 열 추가
df["2010-2015 증가율"] = df["2010-2015 증가율"] * 100
df

# "2005-2010 증가율" 이라는 이름의 열 추가
df["2005-2010 증가율"] = ((df["2010"] - df["2005"]) / df["2005"] * 100).round(2)
df

# 열 인덱싱

# 데이터프레임은 열 라벨을 키로, 열 시리즈를 값으로 가지는 딕셔너리와 비슷함
# 따라서 데이터프레임을 인덱싱 할 때도 열 라벨(column label)을 키값으로 생각하여 인덱싱 함
# 인덱스로 라벨값을 하나만 넣으면 시리즈 객체가 반환되고, 라벨의 배열 또는 리스트를 넣으면 부분적인 데이터 프레임 반환

# 하나의 열만 인덱싱하면 시리즈가 반환됨
df["지역"]

# 여러개의 열을 인덱싱하면 부분적인 데이터프레임 반환됨
df [["2010","2015"]]

# 2010이라는 열을 반환하면서 데이터프레임 자료형을 유지
df[["2010"]]

type(df["2010"])

# 데이터프레임의 열 인덱스가 문자열 라벨을 가지고 있는 경우에는 순서를 나타내는 정수 인덱스를 열 인덱싱에 사용할 수 없음
# 정수 인덱싱의 슬라이스는 행(row)을 인덱싱할 때 사용하므로 열을 인덱싱할 때는 쓸 수 없음
# 정수 인덱스를 넣으면 keyError 오류 발생

df[0]

# 원래부터 문자열이 아닌 정수형 열 인덱스를 가지는 경우에는 인덱스 값으로 정수 사용 가능

import numpy as np

df2 = pd.DataFrame(np.arange(12).reshape(3,4))
df2

df2[2]

df2[[1,2]]

# 행 인덱싱

# 만약 행 단위로 인덱싱을 하고자 하면 항상 슬라이싱(slicing)을 해야함
# 인덱스의 값이 문자 라벨이면 라벨 슬라이싱도 가능

df[:1]

df[1:2]

df[1:3]

df["서울":"부산"]

#개별 데이터 인덱싱
# 데이터 프레임에서 열 라벨로 시리즈를 인덱싱하면 시리즈가 됨
# 이 시리즈를 다시 행 라벨로 인덱싱하면 개별 데이터가 나옴

df["2015"]["서울"]

# ex : 다음 데이터프레임에서 지정하는 데이터를 뽑아내거나 처리

data = {"국어" : [80,90,70,30],
"영어" : [90,70,60,40],
"수학" : [90,60,80,70],}

columns = ["국어","영어","수학"]
index = ["춘향", "몽룡", "향단", "방자"]

df = pd.DataFrame(data, index=index, columns=columns)
df

df["수학"] # 모든 학생의 수학 점수

# 모든 학생의 국어와 영어 점수를 데이터 프레임 
df["국어":"영어"]

# 모든 학생의 각 과목 평균 점수를 새로운 열로 추가
df["평균 점수"] = ((df["국어"] + df["영어"] + df["수학"])/3).round(2)
df

df

df["영어"]["방자"] = 90 # 방자의 영어 점수를 90점으로 수정, 평균 점수 다시 계산
df

df["평균 점수"] = ((df["국어"] + df["영어"] + df["수학"])/3).round(2)
df

